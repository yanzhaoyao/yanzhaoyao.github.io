{"meta":{"title":"Mr·Yan 的博客","subtitle":null,"description":"加油ヾ(◍°∇°◍)ﾉﾞ","author":"Mr·Yan","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-11-22T12:18:00.226Z","updated":"2018-11-22T12:18:00.226Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"about","date":"2018-11-22T13:50:17.000Z","updated":"2018-11-22T13:50:17.996Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-22T13:55:57.400Z","updated":"2018-11-22T13:55:57.400Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-22T13:49:36.865Z","updated":"2018-11-22T13:49:36.865Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从现实生活理解Spring 中常用的设计模式","slug":"从现实生活理解Spring-中常用的设计模式","date":"2018-11-22T14:25:27.000Z","updated":"2018-11-23T14:26:37.275Z","comments":true,"path":"2018/11/22/从现实生活理解Spring-中常用的设计模式/","link":"","permalink":"http://yoursite.com/2018/11/22/从现实生活理解Spring-中常用的设计模式/","excerpt":"","text":"Spring 中常用的设计模式1、我们通常说的 23 中经典设计模式可以通过下表一目了然： 分类 设计模式 创建型 工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、 建造者模式（Builder）、原型模式（Prototype）、单例模式(Singleton) 结构型 适配器模式(Adapter)、桥接模式（Bridge）、组合模式（Composite）、装饰器模式（Decorator）、门面(外观)模式（Facade）、享元模式（Flyweight）、代理模式（Proxy） 行为型 解释器模式（Interpreter）、模板方法模式（Template Method）、责任链模式（Chain of Responsibility）、命令模式（Command）、迭代器模式（Iterator）、调解(中介)者模式（Mediator）、备忘录模式（Memento）、观察者模式（Observer）、状态模式（State）、策略模式（Strategy）、访问者模式（Visitor） 通常来说，设计模式都是混合使用，不会独立应用。利用穷举法充分理解设计模式的应用场景。在平时的应用中，不是用设计模式去生搬硬套，而是根据具体业务问题需要时借鉴。 2、设计模式在应用中遵循六大原则：a、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 b、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 c、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 d、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 e、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 f、组合/聚合复用原则（Composite/Aggregate Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 设计模式之间的关系图 3、接下来我们只介绍在 Spring 中常用的设计模式。1.1、简单工厂模式（Factory）应用场景：又叫做静态工厂方法（StaticFactory Method）模式，但不属于 23 种设计模式之一。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 Spring 中的 BeanFactory 就是简单工厂模式的体现，根据传入一个唯一的标识来获得 Bean 对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。 归类 特点 穷举 创建型模式 是复杂工厂模式的思维模型 批量生产、标准化 1.2、工厂方法模式（Factory Method）应用场景：通常由应用程序直接使用 new 创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。 一般情况下,应用程序有自己的工厂对象来创建 Bean.如果将应用程序自己的工厂对象交给 Spring 管理,那么Spring 管理的就不是普通的 Bean,而是工厂 Bean。 归类 特点 穷举 创建型模式 对于调用者来说，隐藏了复杂的逻辑处理过程，调用者只关心执行结果。对于工厂来说要对结果负责，保证生产出符合规范的 流水线生产 1.3、单例模式（Singleton）应用场景：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 Spring 中的单例模式完成了后半句话，即提供了全局的访问点 BeanFactory。但没有从构造器级别去控制单例，这是因为 Spring 管理的是是任意的 Java 对象。 Spring 下默认的 Bean 均为单例。 归类 特点 穷举 创建型模式 保证从系统启动到系统终止，全过程只会产生一个实例当我们在应用中遇到功能性冲突的时候，需要使用单例模式。 配置文件、日历、IOC 容器 常用单例模式写法：饿汉式、懒汉式、注册式、序列化。 1.4、原型模式（Prototype）应用场景：原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。所谓原型模式，就是 Java 中的克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原型对象的特点，效率高（避免了重新执行构造过程步骤）。 归类 特点 穷举 创建型模式 首先有一个原型。 数据内容相同，但对象实例不同（完全两个个体）。 孙悟空吹毫毛 1.5、代理模式（Proxy）应用场景：为其他对象提供一种代理以控制对这个对象的访问。从结构上来看和 装饰者（Decorator） 模式类似，但 Proxy 是控制，更像是一种对功能的限制，而 装饰者（Decorator）是增加职责。 Spring 的 Proxy 模式在 AOP 中有体现，比如 JdkDynamicAopProxy 和 Cglib2AopProxy。 归类 特点 穷举 结构型模式 执行者、被代理人 对于被代理人来说，这件事情是一定要做的，但是我自己又不想做或者没有时间做。对于代理人而言，需要获取到被代理的人个人资料，只是参与整个过程的某个或几个环节。 租房中介、售票黄牛、婚介经纪人、快递、 事务代理、非侵入式日志监听 1.6、策略模式（Strategy）应用场景：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 Spring 中在实例化对象的时候用到 Strategy 模式，在 SimpleInstantiationStrategy 有使用。 归类 特点 穷举 行为型模式 最终执行结果是固定的。执行过程和执行逻辑不一样。 旅游出行方式 1.7、模板方法模式（Template Method）定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 Template Method 模式一般是需要继承的。这里想要探讨另一种对 Template Method 的理解。Spring中的 JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到 JdbcTemplate 已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate 的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate 中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate 中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到 JdbcTemplate，从而完成了调用。这就是Template Method 不需要继承的另一种实现方式。 归类 特点 穷举 行为型模式 执行流程固定，但中间有些步骤有细微差别（运行时才确定）。可实现批量生产。 Spring ORM 数据模型 1.8、委派模式（Delegate）应用场景：不属于 23 种设计模式之一，是面向对象设计模式中常用的一种模式。这种模式的原理为类 B 和类 A 是两个互相没有任何关系的类，B 具有和 A 一模一样的方法和属性；并且调用 B 中的方法，属性就是调用 A 中同名的方法和属性。B 好像就是一个受 A 授权委托的中介。第三方的代码不需要知道 A 的存在，也不需要和 A 发生直接的联系，通过 B 就可以直接使用 A 的功能，这样既能够使用到 A 的各种功能，又能够很好的将 A 保护起来了，一举两得。 归类 特点 穷举 行为型模式 要和代理模式区分开来。持有被委托人的引用。不关心过程，只关心结果。 经 理 派 发 工 作 任 务Dispatcher 1.9、适配器模式（Adapter）Spring AOP 模块对 BeforeAdvice、AfterAdvice、ThrowsAdvice 三种通知类型的支持实际上是借助适配器模式来实现的，这样的好处是使得框架允许用户向框架中加入自己想要支持的任何一种通知类型，上述三种通知类型是 Spring AOP 模块定义的，它们是 AOP 联盟定义的 Advice 的子类型。 归类 特点 穷举 结构型模式 注重兼容、转换。适配者与被适配这之间没有层级关系，也没有必然联系满足 has-a 的关系。 编码解码、一拖三充电头、 HDMI 转 VGA、Type-C 转 USB 1.10、装饰器模式（Decorator）应用场景：在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在 Spring 和 Hibernate 框架中总是配置一个数据源，因而 SessionFactory 的 DataSource 属性总是指向这个数据源并且恒定不变，所有 DAO 在使用SessionFactory 的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的 DAO 在访 问 SessionFactory 的 时 候 都 不得不在多个数据源中不断切换，问题就出现了：如何让SessionFactory 在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在 Spring 的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ 首先想到在 Spring 的 ApplicationContext 中配置所有的 DataSource。这些 DataSource 可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL 等，也可能是不同的数据源：比如Apache 提供的org.apache.commons.dbcp.BasicDataSource 、 Spring 提 供 的 org.springframework.jndi.JndiObjectFactoryBean 等。然后 SessionFactory 根据客户的每次请求，将 DataSource 属性设置成不同的数据源，以到达切换数据源的目的。 Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 归类 特点 穷举 结构型模式 1、注重覆盖、扩展。2、装饰器和被装饰器都实现同一个接口，主要目的是为了扩展之后依旧保留OOP 关系（同宗同源）。必然联系3、满足 is-a 的关系。 IO 流包装、数据源包装简历包装 1.11、观察者模式（Observer）应用场景：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 Spring 中 Observer 模式常用的地方是 Listener 的实现。如 ApplicationListener。 归类 特点 穷举 行为型模式 一般由两个角色组成：发布者和订阅者（观察者）。观察者通常有一个回调，也可以没有。 监听器、日志收集、短信通知、邮件通知 1.12、各设计模式对比及编程思想总结 设计模式 一句话归纳 工厂模式（Factory） 只对结果负责，不要三无产品。 单例模式（Singleton） 保证独一无二。 适配器模式（Adapter） 需要一个转换头（兼容）。 装饰器模式（Decorator） 需要包装，但不改变本质(同宗同源)。 代理模式（Proxy） 办事要求人，所以找代理。 观察者模式（Observer） 完成时通知我。 策略模式（Strategy） 我行我素，达到目的就行。 模板模式（Template） 流程标准化，原料自己加。 委派模式（Delegate） 干活是你的（普通员工），功劳是我的（项目经理）。 原型模式（Prototype） 拔一根猴毛，吹出千万个。 编程思想总结 Spring 思想 应用场景（特点） 一句话归纳 AOP Aspect Oriented Programming(面向切面编程) 找出多个类中有一定规律的代码，开发时拆开，运行时再合并。 面向切面编程，即面向规则编程。 解耦，专人做专事。 OOP Object Oriented Programming（面向对象编程）归纳总结生活中一切事物。 封装、继承、多态。 BOP Bean Oriented Programming（面向 Bean 编程）面向 Bean（普通的 java 类）设计程序。 一切从 Bean 开始。 IOC Inversion of Control（控制反转）将 new 对象的动作交给 Spring 管理，并由 Spring 保存已创建的对象（IOC 容器）。 转交控制权（即控制权反转）。 DI/DL Dependency Injection（依赖注入）或者 Dependency Lookup（依赖查找）依赖注入、依赖查找，Spring 不仅保存自己创建的对象，而且保存对象与对象之间的关系。注入即赋值，主要三种方式：构造方法、set 方法、直接赋值。 先理清关系再赋值。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"七大Java架构专题","slug":"七大Java架构专题","date":"2018-11-22T12:29:41.000Z","updated":"2018-11-22T14:14:19.481Z","comments":true,"path":"2018/11/22/七大Java架构专题/","link":"","permalink":"http://yoursite.com/2018/11/22/七大Java架构专题/","excerpt":"","text":"源码分析简介：学习源码中所用到的经典的设计思想 常用设计模式 spring5 MyBatis Proxy 代理模式 IOC容器设计原理及高级特性 代码自动生成器 Factory 工厂模式 AOP设计原理 Mybtis关联查询、嵌套查询 Singleton 单例模式 FactoryBean与BeanFactory 缓存使用场景及选择策略 Prototype 原型模式 Spring事物处理机制 Spring集成下的SqlSession与Mapper Mybatis的事物 Strategy 策略模式 基于SpringJDBC手写ORM框架 分析Mybatis的动态代理真正实现 Delegate 委派模式 SpringMVC九大组件 手写实现Mini版的Mybatis Template 模板方法 SpringMVC与Struts2对比分析 Spring5新特性 分布式简介： 微服务架构简介：围绕微服务的通用模式，学习Spring Cloud的常见用法及原理 性能优化简介：从JVM底层原理到内存优化再到各个中间件的性能调优 工程化简介：工善欲其事必先利其器，选择好的工具，提升开发效率和团队协作效率，让自己有更多的时间来思考 多线程并发编程简介：深入了解底层实现原理 电商项目实战简介：大型电商分布式系统应用实战，利用云服务器搭建真实的开发和部署环境，提高动手能力","categories":[],"tags":[{"name":"hide","slug":"hide","permalink":"http://yoursite.com/tags/hide/"}]},{"title":"Hexo GitHub 搭建我的博客","slug":"Hexo-GitHub-搭建我的博客","date":"2018-11-20T15:08:15.000Z","updated":"2018-11-22T13:21:20.515Z","comments":true,"path":"2018/11/20/Hexo-GitHub-搭建我的博客/","link":"","permalink":"http://yoursite.com/2018/11/20/Hexo-GitHub-搭建我的博客/","excerpt":"","text":"一、前言​ 工作两年了，没有系统的学习过Java知识体系，现在对未来一年做了一个规划，搭建此博客，记录后续学习笔记，也算是为了锻炼自己的文字表达能力。 ​ 我曾经也用过OneNote、CSDN、博客园、写过博客，甚至自己打算写一个博客系统。当然以上都是半途而废…，我不想永远怎么颓废下去。我要开始执行我的未来规划。再半途而废，活该一辈子当码农 ​ 写这个开篇第一篇，就当练手了。还不太会用markdownb编辑器 ​ 废话不多话，为何我要搭建GitHub Pages博客？？？ 二、Github PagesGithub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。Github Pages 支持 自动利用 Jekyll 生成站点，也同样支持纯 HTML 文档，将你的 Jekyll 站 点托管在 Github Pages 上是一个不错的选择。 三、开始搭建Github Pages1、注册属于你自己的Github账号​ 首先进入Github站点,然后进行注册(此处不做详细说明可自行阅读github教程：[1]注册github) 注册完毕后你就拥有了自己的代码仓库了. 2、创建仓库在Github首页右上角头像左侧加号点选择 New repositor(新存储库)或点击这里进行创建一个仓库. 3、开启Github Pages进入设置 找到这一块 当你的仓库名为：用户名.github.io 之后默认开启Github Pages 现在随便选择一个主题,选择上图的 Choose a theme 之后会跳转到下面这个页面 设置完毕后你就可以通过 username.github.io(username为你的用户名访问你的博客了) ## 接下来就需要搭建Hexo了 四、Hexo准备工作要使用Hexo,需要安装Nodejs以及Git 安装Node.js下载Node.js参考:安装Node.js 安装Git下载Git 一路点击Next就行了. 安装Hexo在你需要安装Hexo的目录下(新建一个文件夹)右键选择 Git Bash 12345npm install hexo-cli -g hexo init #初始化网站 npm install hexo g #生成或 hexo generate hexo s #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000 查看了 详细命令请参考Hexo文档 这里介绍一下怎么创建一篇文章 12hexo new &quot;文章名&quot; #新建文章hexo new page &quot;页面名&quot; #新建页面 常用简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 新建一篇文章后就可以预览了,在hexo new之后执行一次生成hexo g再执行hexo s启动本地服务器,如果之前还在hexo s 按Ctrl + C 结束. 添加主题我这里使用的主题是next，为什么使用next，我参考了这个博文 写的很好 安装主题(next主题):12hexo cleangit clone https://github.com/litten/hexo-theme-next.git themes/next 启动主题找到目录下的_config.yml 文件,打开找到 theme：属性并设置为next 更新主题1234cd themes/nextgit pullhexo ghexo s 此时刷新http://localhost:4000/页面就能看到新的主题了. 使用Hexo deploy部署到github还是编辑根目录下_config.yml文件 1234deploy: type: git repo: git@github.com:username/username.github.io.git #这里的网址填你自己的 branch: master 保存后需要提前安装一个扩展： 1npm install hexo-deployer-git --save 接下来就是将Hexo部署到我们的Github仓库上 部署到Github 1.检查SSH keys的设置以下命令均是在Git bash里输入 1cd ~/.ssh 输入上面命令后，如果出现： 1#ssh: No such file or directory 假如你你以前有了，会如下： 123456789ls#此时会显示一些文件mkdir key_backupcp id_rsa* key_backuprm id_rsa* #以上三步为备份和移除原来的SSH key设置ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; #生成新的key文件,邮箱地址填你的Github地址#Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;#接下来会让你输入密码（这里我建议自己的笔记本电脑就不要设置密码了，直接回车就行） 之后就可以看到成功的界面。 2.添加SSH Key到Github进入github首页 添加SSH Key。 找到 系统当前用户目录下(开启查看隐藏文件) C:\\Users\\用户名\\ .ssh id_rsa.pub文件以文本方式打开。打开之后全部复制到key中 到了这就可以测试一下是否成功了: 12ssh -T git@github.com#之后会要你输入yes/no,输入yes就好了。 设置你的账号信息: 12git config --global user.name &quot;你的名字&quot; #真实名字不是github用户名git config --global user.email &quot;邮箱@邮箱.com&quot; #github邮箱 3.部署到github1hexo d 这时再刷新 username.github.io 就可以看到你的博客了。 到了这你以为就结束了吗？没有，还有坑没有给你们填好。 六、最后的补充 电脑重装了系统/多台电脑写博客？那就赶紧戳这里使用hexo，如果换了电脑怎么更新博客？ 不知道如何编写Markdown语法？Markdown——入门指南 想要给网站添加图片？请把图片放入根目录 source\\ 下建立一个文件夹，当你执行hexo g的时候此文件夹自动生成到public中。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/博客搭建/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"http://yoursite.com/tags/GitHub-Pages/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-20T14:12:53.300Z","updated":"2018-11-20T12:54:16.184Z","comments":true,"path":"2018/11/20/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}